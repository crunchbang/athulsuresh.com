<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Notes from &#39;Linux Kernel Development&#39; | Core Dump</title>
<meta name="keywords" content="">
<meta name="description" content="This book had been on my TO-READ list for a long time. It came up again while I was perusing Dan Luu&rsquo;s Programming book list. I&rsquo;ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.
I used bootlin to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.">
<meta name="author" content="Athul Suresh">
<link rel="canonical" href="//localhost:1313/posts/04-notes-linux-dev/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="//localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="//localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="//localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="//localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="//localhost:1313/posts/04-notes-linux-dev/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="//localhost:1313/posts/04-notes-linux-dev/">
  <meta property="og:site_name" content="Core Dump">
  <meta property="og:title" content="Notes from &#39;Linux Kernel Development&#39;">
  <meta property="og:description" content="This book had been on my TO-READ list for a long time. It came up again while I was perusing Dan Luu’s Programming book list. I’ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.
I used bootlin to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2020-06-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2020-06-16T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Notes from &#39;Linux Kernel Development&#39;">
<meta name="twitter:description" content="This book had been on my TO-READ list for a long time. It came up again while I was perusing Dan Luu&rsquo;s Programming book list. I&rsquo;ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.
I used bootlin to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "//localhost:1313/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Notes from 'Linux Kernel Development'",
      "item": "//localhost:1313/posts/04-notes-linux-dev/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Notes from 'Linux Kernel Development'",
  "name": "Notes from \u0027Linux Kernel Development\u0027",
  "description": "This book had been on my TO-READ list for a long time. It came up again while I was perusing Dan Luu\u0026rsquo;s Programming book list. I\u0026rsquo;ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.\nI used bootlin to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.\n",
  "keywords": [
    
  ],
  "articleBody": "This book had been on my TO-READ list for a long time. It came up again while I was perusing Dan Luu’s Programming book list. I’ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.\nI used bootlin to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.\nProcess \u0026 Threads A process begins it life with fork()\nLifecycle: fork() [Create a copy of the current running process] -\u003e exec() [Load a binary into memory] -\u003e exit()\nMetadata about each process is stored in a task_struct. Info about all processes are maintained in a linked-list called the tasklist. They’re often referred to as process descriptors.\nthread_info struct is present at the bottom of the stack (for stacks that grow down). This allows for a lot of neat optimizations whereby the thread_info of the current process can be computed and found pretty quickly(review).\nfork() is implemented through Copy-On-Write (COW) pages. Resources are duplicated only when they are modified. The gain comes through not duplicating the address space!\nThreads in linux are no different from processes. Each thread has it’s own task_struct and is scheduled like any other task. Certain params in the task_struct have common values to indicate that resources are shared. This is different from Windows where threads are seen as lightweight processes, where the kernel has explicit support for dealing with threads.\nKernel threads are a special class of threads that run only in kernel space. Forked from kthreadd for performing special ops like flush, ksoftirqd.\nScheduling O(1) scheduler, followed by the Completely Fair Scheduler\nSticking to conventional ideas of an absolute time slice ensures constant switching rate but variable fairness and can lead to a slew of problems. CFS does away with this by ditching timeslices and allocating a portion of the processor to each process. This results in variable switching rate but constant fairness.\nCFS works by assuming that there is an ideal processor that is capable of multitasking. If we have n processes, each would run in parallel, consuming 1/n of the processor. Reality deviates from this ideal dream in the fact that perfect multitasking is not possible, and that there is an overhead involved in switching processes. Nevertheless, CFS is designed with the idea of giving a portion of the processor to each running process. This portion assigned is a function of the total number of processes waiting to be run. Nice values are used here to weight the processor portion that each process receives - a lower niceness value would result in a relatively higher portion of the processor. Thus when we take an infinitely small time window, each process would’ve been scheduled for a time slice proportional to their processor portion.\nThis infinitely small window is usually approximated to a duration called targeted latency. Smaller value results in higher interactivity since it approximates the ideal case, but it results in lower throughput because of switching overhead. targeted latency is floored at a value called minimum granularity by the kernel.\nAll the scheduling info is carried in sched_entity which is embedded in each task_struct.\nThe most interesting thing here is the vruntime, the virtual run time, which is what the scheduler uses to pick the next process. There is a concept of physical time and virtual time. Physical run time is the actual time that the process ran and virtual run time is normalized physical time computed using the number of runnable processes and the niceness value of the process. Approximately, it is computed as physcial_time * (NICE_0_LOAD / proc_load) where NICE_0_LOAD represents the weight of a process who’s niceness value is 0 and proc_load represents the weight of the process calculated using its niceness value. Thus for processes with lower niceness value (higher priority), the virtual time would be less than physical time and vice versa. Thus they’d get a bigger portion of the processor in turn. This SO answer goes into some more depth.\nCFS maintains runnable procs in a red-black tree where the key is the vruntime. It continuously picks and schedules the process with the lowest vruntime. It does a neat optimization where it caches the left-most node during insertion / deletion of each new node.\nWhen a task goes to sleep, it marks itself as sleeping, puts itself on a wait Q, removes itself from the red-black tree of runnables and calls schedule() to select the new process to execute. To wake up the task, it is marked as runnable, removed from the wait Q, and put back in the runnable tree.\nSystem Calls System calls provide an interface between the applications in user space and the kernel. They provide a mechanism through which applications can safely interact with the underlying hardware, create new processes, communicate with each other, as well as the capability to request other operating system resources. Provide mechanism, not policy. The kernel system calls provide a specific fn. The manner in which it is used does not matter to the kernel.\nUser space applications cannot directly invoke a kernel function. The whole communications happens through register values and interrupts. Each syscall has a particular value associated with it. This value is loaded into the eax register and then an interrupt is invoked int 0x80 which invokes the interrupt handler which hands over control to the kernel, which then executes the appropriate system call on behalf of the user space application.\nMost of the system calls are defined with the funky SYSCALL_DEFINE macro. This answer explains the curious asmlinkage that gets prefixed to these functions. Syscall bar is referred to as syscall_bar within the kernel.\nKernel Data Structures The ubiquitous linked list implementation is a circular doubly linked list… with some quirks. Unlike usual linked lists, the data is not embedded within the linked list struct but rather the linked list struct struct list_head is embedded within the data struct. The kernel uses some C macro magic with container_of to get a pointer to the embedding struct from the list_head pointer. This post demystifies the magic behind the macro.\nIn addition the kernel code also contains implementations for a queue (with the usual ops) and a map. The map is implemented as a balanced binary search tree with a rather confusing name - idr. It provides mapping between UIDs to pointers.\nInterrupts \u0026 Interrupt Handlers Interrupts generated by H/W are handled by specific Interrupt Handlers or Interrupt Service Routines (ISR). Generally the ISR for a device is part of the device driver code in the kernel. ISR in the kernel are nothing but C functions that run in the interrupt context (atomic context). The work associated with handling an interrupt is divided into two parts -\nAcknowledging the H/W and performing operations that will enable the H/W will proceed further (stuff like copying all the received packets from a NIC’s buffer) - This is handled by the ‘Top Half’. Further work on the data associated with the kernel, which is not critical and can be performed at a future point in time - This is handled by the ‘Bottom Half’. An interrupt handler is registered for an IRQ line using request_irq() which takes in information about the IRQ number, handler fn, flags pertaining to the nature of the interrupt and handler, and some extra stuff. The registration happens when the driver is loaded. Similarly, when the driver is unloaded the handler needs to be freed using free_irq().\nInterrupt handlers in linux need to be reentrant i.e the handler will not be invoked concurrently. When an interrupt is being service, the interrupt line is disabled (masked) which prevents further interrupts from coming on that line. Thus it is guaranteed that the ISR won’t be invoked in parallel.\nInterrupt lines may be shared among multiple handlers. For a line to be shared, each handler on that line must be registered as a shared handler. The handler returns a value denoting whether the interrupt was handled or not. When an interrupt is received on a shared line, the kernel invokes each of the handlers one by one. It uses the return value to ascertain whether the interrupt was handled.\nInterrupt handlers run in the interrupt context. Since it is not backed by a process, ISR are not allowed to sleep (who will wake it up and how?), which restricts the activities that can be done from ISR. Earlier ISR was forced to use the stack of the process it interrupted. Now, there is an interrupt stack associated with the kernel which is of size equivalent to one page which the ISR can use.\ncat /proc/interrupts shows the interrupt line, the number of interrupts received by each CPU, the interrupt controller, the interrupt type, and the device.\nBottom halves may be implemented using softirqs, tasklets, or work queues.\nSynchronization Locks are implemented using atomic test and set insturctions that are provided by the underlying architecture. Atomic operations using atomic_t. There’s a lot to talk about here. In the book, which is based on linux kernel 2.6, atomic_t is implemented as a volatile int inside a struct. The struct was chosen so that there would be no way to cast it into another valid form. The choice of volatile does not seem to have survived the test of time, with more recent variants moving away from it altogether. This document goes through the structure and behavior of the latest version of atomic_t, in addition, it also sheds light on why volatile should not be used. Most of these arise because of the reliance on volatile to enforce a memory barrier while it actually does not. This SO answer illustrates cases where volatile can be justifiably used to prevent the compiler from optimising away checks and conditions that rely on MMIO.\natomic_t provides atomic operations to manipulate integers and bits. This is useful in cases where the critical region does not perform any operation more complicated than that. Locks are used when the critical regions are more complex, where multiple operations need to be performed while still ensuring atomicity.\nSpin lock are a form of locking provided by the kernel, where the thread busy waits (spins) until the lock is acquired. This might seem inefficient in comparison to scenarios where the threads are put to sleep if the lock is not available. In cases where the locks are held for a short duration of time (or in code paths where you cannot sleep), spinlocks are efficient as it foregoes the overhead of scheduling involved with sleeping the thread and waking it up. An interesting fact is that the locks compile away in uniprocessor machines to markers that disable and enable kernel pre-emption. Interrupt handlers can use spin-locks, provided local interrupts to the current processor are disabled (this ensures that we do not get stuck with a double acquire deadlock). Lock data not code. Reader/writer variant of the spin lock is also provided by the kernel. A RW spin lock always favors readers. A sufficient number of readers could cause the starvation of the writer!\nSemaphores in linux are sleeping locks. Can only be used in process context since it is not possible to sleep in an interrupt context (as they won’t be rescheduled). Variants : binary semaphores (mutex) and counting semaphores. In addition, there’s a rwsemaphore and a mutex(as a separate struct with a simpler interface).\nThere’s another curious thing called the completion variable provided by the kernel. This is useful is scenarios where one process is waiting for a singal from the other indicating completion. A semaphore can be used here, but completion variable provides a simpler interface.\nIn addition to all of this there’s the Big Kernel Lock (BKL) that was added to ease the SMP transition. It’s a recursive, global spin lock that can be used in the process context. It’s interesting to note how different projects got started with coarse grained locking, and later moved to fine grained locking as the project matured and the need for concurrency grew. I wonder when Python will tide over the Global Interpreter Lock(GIL).\nJust when you thought you couldn’t need another locking mechanism, the kernel throws seqlocks in your face. This is sort of like the RW locks seen earlier, with the difference being that writers are preferred over readers. Each locked data is associated with a sequence counter (which is the thing that’s protected by the lock). During a write, the counter is incremented. A read operation checks the sequence counter prior to and after the read. A read succeeds(as in, a write did not happen in between), if the values match. Thus, writers are never blocked, and dirty reads would just cause the reader to retry the read until the counter conditions are satisfied.\nOrdering \u0026 Barriers The processor and compiler might reorder memory accesses (reads and write) in code for a variety of reasons which might break some implicit assumptions that the code relies on. Barriers can be used to enforce the ordering and to indicate to the compiler / processor to maintain the order of operations. mb()/rmb()/wmb() provide memory barrier / read memory barrier / write memory barrier which ensure that rw / reads / writes are not reordered across them i.e all corresponding ops before the barrier are guaranteed to complete before the ops after it.\nMemory Management Pages are treated as the smallest unit of memory management. Memory is divided in multiple zone, each zone with a particular characteristic (DMA, normal, high memory etc). Allocations will never cross zone boundaries. Pages returned to user-space are zeroed out to ensure security. kmalloc allocates memory that is physically contiguous while vmalloc allocates memory that is contiguous in the virtual address space.\nFile Managements VFS abstraction layers allows userland programs to be agnostic of the underlying fs. Main components: superblock, inode, dentry, file.\nBlock Devices Sectors, blocks, buffers, and buffer heads. The IO scheduler mergers and sorts requests on the block device to maximize “global” throughput. Anticipatory, deadline, completely fair queuing, and noop variant.\nTODO Interesting but not interesting enough for now Interrupt Handler Bottoms - softirq, tasklets Slab allocator ",
  "wordCount" : "2379",
  "inLanguage": "en",
  "datePublished": "2020-06-16T00:00:00Z",
  "dateModified": "2020-06-16T00:00:00Z",
  "author":[{
    "@type": "Person",
    "name": "Athul Suresh"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "//localhost:1313/posts/04-notes-linux-dev/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Core Dump",
    "logo": {
      "@type": "ImageObject",
      "url": "//localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="//localhost:1313/" accesskey="h" title="Core Dump (Alt + H)">Core Dump</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="//localhost:1313/archive/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/books/" title="Books">
                    <span>Books</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/index.xml" title="RSS">
                    <span>RSS</span>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/crunchbang/athulsuresh.com" title="Source">
                    <span>Source</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="//localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="//localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="//localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Notes from &#39;Linux Kernel Development&#39;
    </h1>
    <div class="post-meta"><span title='2020-06-16 00:00:00 +0000 UTC'>2020-06-16</span>&nbsp;·&nbsp;Athul Suresh

</div>
  </header> 
  <div class="post-content"><p>This book had been on my TO-READ list for a long time. It came up again while I was perusing <a href="https://danluu.com/programming-books/">Dan Luu&rsquo;s Programming book list</a>. I&rsquo;ve always wanted to look behind the curtains and see how the magic worked, so I finally bought it.</p>
<p>I used <a href="https://elixir.bootlin.com/linux/v5.7.2/C/ident/task_struct">bootlin</a> to read through Linux 5.7.2 source. They provide a really good search system and linked definitions. The book describes kernel version 2.6. You might want to keep this site open to see how things have changed since then.</p>
<h2 id="process-and-threads">Process &amp; Threads<a hidden class="anchor" aria-hidden="true" href="#process-and-threads">#</a></h2>
<p>A process begins it life with <code>fork()</code></p>
<p>Lifecycle: <code>fork()</code> [Create a copy of the current running process] -&gt; <code>exec()</code> [Load a binary into memory] -&gt; <code>exit()</code></p>
<p>Metadata about each process is stored in a <code>task_struct</code>. Info about all processes are maintained in a linked-list called the tasklist. They&rsquo;re often referred to as process descriptors.</p>
<p><code>thread_info</code> struct is present at the bottom of the stack (for stacks that grow down). This allows for a lot of neat optimizations whereby the <code>thread_info</code> of the current process can be computed and found pretty quickly(review).</p>
<p><code>fork()</code> is implemented through Copy-On-Write (COW) pages. Resources are duplicated only when they are modified. The gain comes through not duplicating the address space!</p>
<p>Threads in linux are no different from processes. Each thread has it&rsquo;s own <code>task_struct</code> and is scheduled like any other task. Certain params in the <code>task_struct</code> have common values to indicate that resources are shared. This is different from Windows where threads are seen as lightweight processes, where the kernel has explicit support for dealing with threads.</p>
<p>Kernel threads are a special class of threads that run only in kernel space. Forked from <code>kthreadd</code> for performing special ops like flush, ksoftirqd.</p>
<h2 id="scheduling">Scheduling<a hidden class="anchor" aria-hidden="true" href="#scheduling">#</a></h2>
<p>O(1) scheduler, followed by the Completely Fair Scheduler</p>
<p>Sticking to conventional ideas of an absolute time slice ensures constant switching rate but variable fairness and can lead to a slew of problems. CFS does away with this by ditching timeslices and allocating a portion of the processor to each process. This results in variable switching rate but constant fairness.</p>
<p>CFS works by assuming that there is an ideal processor that is capable of multitasking. If we have n processes, each would run in parallel, consuming 1/n of the processor. Reality deviates from this ideal dream in the fact that perfect multitasking is not possible, and that there is an overhead involved in switching processes. Nevertheless, CFS is designed with the idea of giving a portion of the processor to each running process. This portion assigned is a function of the total number of processes waiting to be run. Nice values are used here to weight the processor portion that each process receives - a lower niceness value would result in a relatively higher portion of the processor. Thus when we take an infinitely small time window, each process would&rsquo;ve been scheduled for a time slice proportional to their processor portion.</p>
<p>This infinitely small window is usually approximated to a duration called <code>targeted latency</code>. Smaller value results in higher interactivity since it approximates the ideal case, but it results in lower throughput because of switching overhead. <code>targeted latency</code> is floored at a value called <code>minimum granularity</code> by the kernel.</p>
<p>All the scheduling info is carried in <code>sched_entity</code> which is embedded in each <code>task_struct</code>.</p>
<p>The most interesting thing here is the <code>vruntime</code>, the virtual run time, which is what the scheduler uses to pick the next process. There is a concept of physical time and virtual time. Physical run time is the actual time that the process ran and virtual run time is normalized physical time computed using the number of runnable processes and the niceness value of the process. Approximately, it is computed as <code>physcial_time * (NICE_0_LOAD / proc_load)</code> where <code>NICE_0_LOAD</code> represents the weight of a process who&rsquo;s niceness value is 0 and <code>proc_load</code> represents the weight of the process calculated using its niceness value. Thus for processes with lower niceness value (higher priority), the virtual time would be less than physical time and vice versa. Thus they&rsquo;d get a bigger portion of the processor in turn. This <a href="https://stackoverflow.com/questions/19181834/what-is-the-concept-of-vruntime-in-cfs/19193619">SO</a> answer goes into some more depth.</p>
<p>CFS maintains runnable procs in a red-black tree where the key is the <code>vruntime</code>. It continuously picks and schedules the process with the lowest <code>vruntime</code>. It does a neat optimization where it caches the left-most node during insertion / deletion of each new node.</p>
<p>When a task goes to sleep, it marks itself as sleeping, puts itself on a wait Q, removes itself from the red-black tree of runnables and calls <code>schedule()</code> to select the new process to execute. To wake up the task, it is marked as runnable, removed from the wait Q, and put back in the runnable tree.</p>
<h2 id="system-calls">System Calls<a hidden class="anchor" aria-hidden="true" href="#system-calls">#</a></h2>
<p>System calls provide an interface between the applications in user space and the kernel. They provide a mechanism through which applications can safely interact with the underlying hardware, create new processes, communicate with each other, as well as the capability to request other operating system resources. Provide mechanism, not policy. The kernel system calls provide a specific fn. The manner in which it is used does not matter to the kernel.</p>
<p>User space applications cannot directly invoke a kernel function. The whole communications happens through register values and interrupts. Each syscall has a particular value associated with it. This value is loaded into the <code>eax</code> register and then an interrupt is invoked <code>int 0x80</code> which invokes the interrupt handler which hands over control to the kernel, which then executes the appropriate system call on behalf of the user space application.</p>
<p>Most of the system calls are defined with the funky <code>SYSCALL_DEFINE</code> macro. This <a href="https://www.quora.com/Linux-Kernel/Linux-Kernel-What-does-asmlinkage-mean-in-the-definition-of-system-calls">answer</a> explains the curious <code>asmlinkage</code> that gets prefixed to these functions. Syscall <code>bar</code> is referred to as <code>syscall_bar</code> within the kernel.</p>
<h2 id="kernel-data-structures">Kernel Data Structures<a hidden class="anchor" aria-hidden="true" href="#kernel-data-structures">#</a></h2>
<p>The ubiquitous linked list implementation is a circular doubly linked list&hellip; with some quirks. Unlike usual linked lists, the data is not embedded within the linked list struct but rather the linked list struct <code>struct list_head</code> is embedded within the data struct. The kernel uses some C macro magic with <code>container_of</code> to get a pointer to the embedding struct from the <code>list_head</code> pointer. This <a href="https://radek.io/2012/11/10/magical-container_of-macro/">post</a> demystifies the magic behind the macro.</p>
<p>In addition the kernel code also contains implementations for a queue (with the usual ops) and a map. The map is implemented as a balanced binary search tree with a rather confusing name - idr. It provides mapping between UIDs to pointers.</p>
<h2 id="interrupts-and-interrupt-handlers">Interrupts &amp; Interrupt Handlers<a hidden class="anchor" aria-hidden="true" href="#interrupts-and-interrupt-handlers">#</a></h2>
<p>Interrupts generated by H/W are handled by specific Interrupt Handlers or Interrupt Service Routines (ISR). Generally the ISR for a device is part of the device driver code in the kernel. ISR in the kernel are nothing but C functions that run in the interrupt context (atomic context). The work associated with handling an interrupt is divided into two parts -</p>
<ol>
<li>Acknowledging the H/W and performing operations that will enable the H/W will proceed further (stuff like copying all the received packets from a NIC&rsquo;s buffer) - This is handled by the &lsquo;Top Half&rsquo;.</li>
<li>Further work on the data associated with the kernel, which is not critical and can be performed at a future point in time - This is handled by the &lsquo;Bottom Half&rsquo;.</li>
</ol>
<p>An interrupt handler is registered for an IRQ line using <code>request_irq()</code> which takes in information about the IRQ number, handler fn, flags pertaining to the nature of the interrupt and handler, and some extra stuff. The registration happens when the driver is loaded. Similarly, when the driver is unloaded the handler needs to be freed using <code>free_irq()</code>.</p>
<p>Interrupt handlers in linux need to be reentrant i.e the handler will not be invoked concurrently. When an interrupt is being service, the interrupt line is disabled (masked) which prevents further interrupts from coming on that line. Thus it is guaranteed that the ISR won&rsquo;t be invoked in parallel.</p>
<p>Interrupt lines may be shared among multiple handlers. For a line to be shared, each handler on that line must be registered as a shared handler. The handler returns a value denoting whether the interrupt was handled or not. When an interrupt is received on a shared line, the kernel invokes each of the handlers one by one. It uses the return value to ascertain whether the interrupt was handled.</p>
<p>Interrupt handlers run in the interrupt context. Since it is not backed by a process, ISR are not allowed to sleep (who will wake it up and how?), which restricts the activities that can be done from ISR. Earlier ISR was forced to use the stack of the process it interrupted. Now, there is an interrupt stack associated with the kernel which is of size equivalent to one page which the ISR can use.</p>
<p><code>cat /proc/interrupts</code> shows the interrupt line, the number of interrupts received by each CPU, the interrupt controller, the interrupt type, and the device.</p>
<p>Bottom halves may be implemented using softirqs, tasklets, or work queues.</p>
<h2 id="synchronization">Synchronization<a hidden class="anchor" aria-hidden="true" href="#synchronization">#</a></h2>
<p>Locks are implemented using atomic test and set insturctions that are provided by the underlying architecture. Atomic operations using <code>atomic_t</code>. There&rsquo;s a lot to talk about here. In the book, which is based on linux kernel 2.6, <code>atomic_t</code> is implemented as a <code>volatile int</code> inside a struct. The struct was chosen so that there would be no way to cast it into another valid form. The choice of <code>volatile</code> does not seem to have survived the test of time, with more recent variants moving away from it altogether. This <a href="https://www.kernel.org/doc/html/latest/core-api/atomic_ops.html">document</a> goes through the structure and behavior of the latest version of <code>atomic_t</code>, in addition, it also sheds light on <a href="https://www.kernel.org/doc/html/latest/process/volatile-considered-harmful.html#volatile-considered-harmful">why volatile should not be used</a>. Most of these arise because of the reliance on <code>volatile</code> to enforce a memory barrier while it actually does not. This <a href="https://stackoverflow.com/questions/246127/why-is-volatile-needed-in-c">SO answer</a> illustrates cases where volatile can be justifiably used to prevent the compiler from optimising away checks and conditions that rely on MMIO.</p>
<p><code>atomic_t</code> provides atomic operations to manipulate integers and bits. This is useful in cases where the critical region does not perform any operation more complicated than that. Locks are used when the critical regions are more complex, where multiple operations need to be performed while still ensuring atomicity.</p>
<p>Spin lock are a form of locking provided by the kernel, where the thread busy waits (spins) until the lock is acquired. This might seem inefficient in comparison to scenarios where the threads are put to sleep if the lock is not available. In cases where the locks are held for a short duration of time (or in code paths where you cannot sleep), spinlocks are efficient as it foregoes the overhead of scheduling involved with sleeping the thread and waking it up. An interesting fact is that the locks compile away in uniprocessor machines to markers that disable and enable kernel pre-emption. Interrupt handlers can use spin-locks, provided local interrupts to the current processor are disabled (this ensures that we do not get stuck with a double acquire deadlock). Lock data not code. Reader/writer variant of the spin lock is also provided by the kernel. A RW spin lock always favors readers. A sufficient number of readers could cause the starvation of the writer!</p>
<p>Semaphores in linux are sleeping locks. Can only be used in process context since it is not possible to sleep in an interrupt context (as they won&rsquo;t be rescheduled). Variants : binary semaphores (mutex) and counting semaphores. In addition, there&rsquo;s a rwsemaphore and a mutex(as a separate struct with a simpler interface).</p>
<p>There&rsquo;s another curious thing called the <code>completion variable</code> provided by the kernel. This is useful is scenarios where one process is waiting for a singal from the other indicating completion. A semaphore can be used here, but <code>completion variable</code> provides a simpler interface.</p>
<p>In addition to all of this there&rsquo;s the Big Kernel Lock (BKL) that was added to ease the SMP transition. It&rsquo;s a recursive, global spin lock that can be used in the process context. It&rsquo;s interesting to note how different projects got started with coarse grained locking, and later moved to fine grained locking as the project matured and the need for concurrency grew. I wonder when Python will tide over the Global Interpreter Lock(GIL).</p>
<p>Just when you thought you couldn&rsquo;t need another locking mechanism, the kernel throws <code>seqlocks</code> in your face. This is sort of like the RW locks seen earlier, with the difference being that writers are preferred over readers. Each locked data is associated with a sequence counter (which is the thing that&rsquo;s protected by the lock). During a write, the counter is incremented. A read operation checks the sequence counter prior to and after the read. A read succeeds(as in, a write did not happen in between), if the values match. Thus, writers are never blocked, and dirty reads would just cause the reader to retry the read until the counter conditions are satisfied.</p>
<h2 id="ordering-and-barriers">Ordering &amp; Barriers<a hidden class="anchor" aria-hidden="true" href="#ordering-and-barriers">#</a></h2>
<p>The processor and compiler might reorder memory accesses (reads and write) in code for a variety of reasons which might break some implicit assumptions that the code relies on. Barriers can be used to enforce the ordering and to indicate to the compiler / processor to maintain the order of operations. <code>mb()/rmb()/wmb()</code> provide memory barrier / read memory barrier / write memory barrier which ensure that rw / reads / writes are not reordered across them i.e all corresponding ops before the barrier are guaranteed to complete before the ops after it.</p>
<h2 id="memory-management">Memory Management<a hidden class="anchor" aria-hidden="true" href="#memory-management">#</a></h2>
<p>Pages are treated as the smallest unit of memory management. Memory is divided in multiple zone, each zone with a particular characteristic (DMA, normal, high memory etc). Allocations will never cross zone boundaries. Pages returned to user-space are zeroed out to ensure security. <code>kmalloc</code> allocates memory that is physically contiguous while <code>vmalloc</code> allocates memory that is contiguous in the virtual address space.</p>
<h2 id="file-managements">File Managements<a hidden class="anchor" aria-hidden="true" href="#file-managements">#</a></h2>
<p>VFS abstraction layers allows userland programs to be agnostic of the underlying fs. Main components: superblock, inode, dentry, file.</p>
<h2 id="block-devices">Block Devices<a hidden class="anchor" aria-hidden="true" href="#block-devices">#</a></h2>
<p>Sectors, blocks, buffers, and buffer heads. The IO scheduler mergers and sorts requests on the block device to maximize &ldquo;global&rdquo; throughput. Anticipatory, deadline, completely fair queuing, and noop variant.</p>
<h2 id="d41d8c"><span class="org-todo todo TODO">TODO</span> <a hidden class="anchor" aria-hidden="true" href="#d41d8c">#</a></h2>
<h3 id="interesting-but-not-interesting-enough-for-now">Interesting but not interesting enough for now<a hidden class="anchor" aria-hidden="true" href="#interesting-but-not-interesting-enough-for-now">#</a></h3>
<ul>
<li>Interrupt Handler Bottoms - softirq, tasklets</li>
<li>Slab allocator</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="//localhost:1313/">Core Dump</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
